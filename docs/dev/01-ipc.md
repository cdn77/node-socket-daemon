# Nodesockd IPC protocol

Nodesockd uses the native IPC channel of NodeJS child processes for communication
between the daemon process and the workers it has launched. Workers which have
been adopted after a daemon upgrade, as well as the `nodesockd/client` library
and the CLI commands which are built on top of it, use an IPC socket to talk to
the daemon. Regardless of the transport mechanism, the communication _protocol_
is always the same.

## Common

The daemon, all the workers and any other IPC clients are collectively called
_peers_ in this document. Peers can exchange one of two types of communication:
messages, which are one-way and don't have any feedback mechanism, and requests,
which will always result in one or more replies, or an error - so the requesting
side will always know whether the request was received by the other side.

### Messages

All messages are JSON-encoded objects whose structure must extend the following
interface:

```typescript
interface IpcMessage {
  type: string;
  data?: JsonObject;
}
```


### Requests, replies and reply streams

Requests are like messages, but they carry an additional `id` property by which
they can be tracked:

```typescript
interface IpcRequest extends IpcMessage {
  id: string;
}
```

The request `id` is a UUID generated by the requesting peer. Replies to
requests must conform to the following interface:

```typescript
interface IpcReply extends IpcMessage {
  type: 'reply';
  requestId: string;
  errors?: string[];
  done?: boolean;
}
```

The `requestId` must be the set to the value of the `id` property of
the `IpcRequest` which the reply belongs to.

The `done` property can be used to signal to the requester that multiple replies
should be expected; the requester should only consider its request to be entirely
fulfilled once it receives an `IpcReply` with the `done` property set to `true`.
This way, peers can send asynchronous _reply streams_ when needed, instead of
single replies.


## Message types

The three peer types each have a map of message and request types which they
can send, and message and request types which they're able to receive.
These maps are defined in the following files:
 - `src/daemon/types.ts` for messages and requests the daemon can send / receive,
 - `src/worker/types.ts` for messages and requests workers can send / receive, and
 - `src/client/types.ts` for messages and requests clients can send / receive

Quite obviously the message types the daemon is able to handle must be a union
of the message types that workers and clients can send, but this is not currently
enforced at the type level.
